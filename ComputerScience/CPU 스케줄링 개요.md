# CPU 스케줄링 개요-이상훈

#### CPU 스케줄링의 필요성

\- 다중 프로그래밍의 목적은 CPU 이용률 최대화 => 가능한 CPU가 항상 실행중인 프로세스를 가지게 한다.

\- 프로세스가 대기 중일 때, 운영체제가 해당 프로세스가 할당된 CPU를 회수해 다른 프로세스에 할당

### CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)

**버스트(burst)**란 특정 기준에 따라 한 단위로서 취급되는 연속된 신호나 데이터의 모임을 말한다. 

즉, 입출력 요청을 위해 CPU 사용을 사용했다가 쉬었다가를 반복한다.

프로세스가 CPU를 사용할때를 **CPU버스트**, 입/출력을 기다릴때를 **입/출력 버스트**라고 한다.

프로세스의 실행은 CPU 버스트를 시작으로 뒤이어 입출력 버스트가 발생하는 식으로 두 버스트의 사이클로 구성된다. 

마지막 CPU버스트는 또 다른 입출력 버스트가 뒤따르는 대신에 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

![](C:\Users\a0511\Desktop\123.JPG)

입출력 중심의 프로그램은 CPU 버스트 시간이 짧을 것이다. 

반대로 CPU 지향 프로그램은 CPU 버스트 시간이 길 것이다. 

이러한 분포는 적절한 CPU 스케줄링 알고리즘을 선택하는데 매우 중요할 수 있다.

### 스케줄러&디스패쳐

#### CPU 스케줄러

\- CPU가 idle(유휴상태)이 되었을 때, ready queue의 프로세스 중 어떤 프로세스를 할당할 것인지 결정

\- 일반적으로 ready queue에 저장된 레코드는 PCB

\- ready queue는 FIFO가 아닌 우선순위 큐, 트리 등 여러 구조를 띈다.

#### 디스패처(Dispatcher)

\- CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 건내주는 모듈

\- 문맥 교환, 사용자 모드 전환, 프로그램을 다시 시작할 때 프로그램의 적절한 위치로 이동하는 일

\- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데 소요되는 시간 => 디스패처 지연

\- 문맥 교환 시 항상 호출되기 때문에, 문맥 교환의 오버헤드를 줄이기 위해 디스패처의 시간 효율은 매우 중요하다.

#### CPU 스케줄링이 발생하는 상황

\- 프로세스가 실행 상태(run)에서 대기 상태(waiting)로 전환될 때

ex) I/O 요청, 자식 프로세스의 종료를 기다리기 위해 wait() 호출 시

\- 프로세스가 실행 상태(run)에서 준비 상태(ready)로 전환될 때

ex) 인터럽트 발생

\- 프로세스가 대기 상태(waiting)에서 준비 상태(ready)로 전환될 때

ex) I/O 종료

\- 프로세스가 종료될 때

#### 스케줄링 성능척도

\- CPU 이용률(utilization): CPU를 얼마나 사용하고 있는가

\- 처리량(throughput): 단위 시간 당 완료된 프로세스의 개수

\- 총처리 시간(turnaround time):

프로세스의 제출 시간과 완료 시간의 간격 (프로세스의 대기 시간(ready queue에서의) + CPU 실행 시간 + I/O 시간)

\- 대기 시간(waiting time): 프로세스의 대기 시간(ready queue에서의)

\- 응답 시간(response time): 요구한 후, 첫 응답이 나올 때 까지의 시간 (응답을 모두 처리할 때가 아니다.)

=> CPU 이용률, 처리량을 최대화하고 총처리 시간, 대기 시간, 응답 시간을 최소화하는 것이 바람직하다.